   PowerPlusWaterMarkObject1

                                                         OpenLCB WorkingTechnical Note

                                                            (title)Traction Protocol

                                                   Apr 29, 2013                        Preliminary          

                                                1 Introduction

   This working note covers the Traction Protocol, the way that OpenLCB handles moving objects such as
   locomotives, engines, and other rolling stock.

   A Working Note is an intermediate step in the documentation process. It gathers together the content
   from various informal development documents, discussions, etc into a single place. One or more Working
   Notes form the basic for the next step, which is one or more Standard/TechNote pairs.

   This protocol is for the long-term operation of really cool trains, not just “better control over DCC”.
   Still, DCC is an important test case, both with new control hardware (OpenLCB native throttles connected
   to an OpenLCB-native command station that's generating the DCC signal) and when connected to legacy
   throttles and/or command stations.

1.1 Terminology

   “DCC” refers to NMRA DCC; “Legacy” refers to all pre-existing protocols including DCC, TMCC, Marklin,
   DCS, etc.

   “Trains”: For our purposes, Train is anything which can be independently controlled. In addition to a
   model of a prototype train from locomotive to caboose, it might be just single caboose, a set of lit &
   controlled passenger cars, a diesel MU lash up, or basically anything that can take an OpenLCB "decoder"
   or a DCC decoder with a legacy attachment.

   “Train Node”: A Train is associated with a single, specific node. The Node ID is the fully-unique
   identifier for that Train.

   “Throttles”: For the purposes of discussion, we draw a distinction between three kinds of throttles that
   a user might encounter:

     * “Legacy Throttles” refers to throttles designed for use with extant DCC systems, e.g. a Digitrax
       DT402 or Lenz LH100.

     * “Full-Featured Throttles” refers to full-featured native OpenLCB throttles with multi-line color
       screens and effectively unlimited processing power, e.g. a software throttle implemented on an iPad.

     * “Simple Throttles” refers to throttles which are native OpenLCB nodes like Full-Featured Throttles,
       but which have more limited capabilities, e.g. no text display, a limited array of physical buttons,
       and constrained processing resources.

   “Proxies”: In the long term, we expect that OpenLCB protocols will go all the way to the train. This has
   great advantages, because you're always in complete communication with the train, and don't have to
   worry about only being able to configure the train when it's on a service track, storing information
   somewhere else so that it can be retrieved while the train is moving, etc. But until radio or other
   technologies mature to the point that this is possible, "proxy nodes" can be used as stand-ins for that
   capability. A throttle might communicate with a node that's serving as a proxy for the train, handling
   the communications, keeping track of status & configuration, etc. Out the back end of that proxy node is
   some other kind of communications, perhaps direct DCC or a connection to a legacy system that in turn
   makes DCC signals, or some other technology entirely. Due to the nature of those back side
   communications methods, the proxy may not be able to do everything that OpenLCB can, or only do some of
   it at certain times. The OpenLCB traction protocols need to take this reality into account. Anther use
   case for proxies, discussed in detail below, is to provide the mechanism for consisting.

   “Command Stations”: Existing DCC and other control systems use “command stations” to create a track
   signal for controlling the trains. Usually the command station is controlled from the user side by some
   other network, to which throttles and other interface devices are connected. OpenLCB, it it's native
   form, has no such concept. Devices, like throttles, that want to talk to a train do so directly. Only
   when working with legacy systems does the concept of a command station enter, and usually through the
   form of a proxy node that is acting for the Train.

   “Consisting”: The running of multiple items together, e.g. three coupled engines, each with their own
   NodeID or DCC address, as a single locomotive. DCC systems provide this now in various ways and with
   various names.

1.2 Served Use Cases

  1.2.1 Train Operation

   Bill hasn't run his passenger train recently on his OpenLCB-equipped layout. He picks up a throttle,
   hits a few keys, sees his passenger train listed, selects it and starts to run it. Some configuration
   needs tweaking (e.g. volume too low), so he enters a configuration dialog on the throttle, finds the
   right item by reading through them, changes the value to be a few larger, and stores that back into the
   train as it's running on the main track. That makes it work immediately.

  1.2.2 Large Modular Layout

   Arnold has put his OpenLCB-equipped train on a large modular layout, where it is one of 500 pieces of
   equipment. He picks up a throttle, presses a few keys, sees his train, selects it and starts to operate
   it.

  1.2.3 Train on New Layout

   Jim takes his OpenLCB-equipped train to Bill's OpenLCB-equipped layout and puts it on the track. He
   picks up a throttle, hits a few keys, sees his train, selects it and starts to run it. On this layout,
   some configuration needs tweaking (e.g. volume too low), so he enters a configuration dialog on the
   throttle, finds the right item by reading through them, changes the value to be a few larger, and stores
   that back into the train. That makes it work. When he gets back home that value is still present so he
   changes it back using the same procedure.

  1.2.4 Legacy Train on New Layout

   Jim takes his DCC-equipped train to Bill's OpenLCB- and DCC-equipped layout and puts it on the track. He
   picks up a throttle, hits a few keys, sees his train, selects it and starts to run it.

   As an alternative, Jim takes his DCC-equipped locomotive to the layout, puts it on the track, enters the
   DCC address into a throttle, and starts to run it.

1.3 Unserved Use Cases

  1.3.1 Multiple Independent Command Stations

   Large modular layouts use multiple command stations to increase the effective bandwidth of the DCC bus.
   This is not an explicitly supported use case in the current work. Future work may make this possible as
   an extension.

  1.3.2 Improved Legacy Addressing

   DCC systems cannot run two locomotives with the same DCC address at the same time. This will still be
   true when running DCC-equipped locomotives via OpenLCB protocols to the command station.

  1.3.3 Third-Party Communications

   Node A is a throttle that is controlling train node B. Node C passively listens to the traffic and
   reacts to throttle commands and train status by taking various actions, such as providing appropriate
   sounds or preventing the speed from getting too high.

                               2 Specified SectionsAnnotations to the Standard

   This is the usual section organization for a Technical Note, to accumulate the Standard and Technical
   Note content in its eventual order.

2.1 Introduction

   Note that this section of the Standard is informative, not normative.

2.2 Intended Use

   Note that this section of the Standard is informative, not normative.

2.3 Reference and Context

   NMRA S9.2 and NMRA RP9.2.1 define the formats for DCC addresses

   Node implementing the Train Protocol must implement:

     * Message Transfer Protocol

     * Event Transfer Protocol

     * Memory Configuration Protocol (optional?) and Datagram Protocol it depends on

     * SNII and/or ACDI?

   Float-16 is the half-precision numeric format defined by IEEE 754-2008. It's available in the GNU tool
   chain via the -mfp16-format=ieee flag and __fp16 type.

2.4 Message Formats

   AA.AA refers to an NMRA short or long address in the format defined by the NMRA. (Say a few words about
   short addresses in two bytes, maybe give examples)

  2.4.1 Defined Event IDs

   IsTrain: 01.01.00.00.00.00.03.03

   IsIdleProxy: 01.01.00.00.00.00.03.04

   IsInUseProxy: 01.01.00.00.00.00.03.05

   IsProxiedDccAddress: 06.01.00.CC.AA.AA.03.03

   EmergencyStopAll: 01.01.00.00.00.00.FF.FF

  2.4.2 Traction Control Command Message

   MTI: Priority 1, index 15, modifier 2, addressed => MTI 0x05EA, CAN frame [195EAsss] fd dd

   The MTI modifiers are chosen to have the reply a higher priority than the request, ensuring replies to
   repeated instructions are always possible. The same priority and index are used for command and reply
   messages, changing only the modifier, to use less of the high-priority MTI space which is a scarce
   resource.

   This message type and MTI is specific to traction control. The first byte of the content codes an
   “instruction”, which defines the rest of the format. The instruction codes were selected with the high
   nibble representing protocol (0x00 for OpenLCB full protocol; 0x80 for DCC legacy; others reserved)

    Instruction          Byte 0  Byte 1              Byte 2       Byte 3  Byte 4    Byte 5  Byte 6  Byte 7  

    Set Speed/Direction  0x00    Speed and direction as signed
                                 float16             

    Set Function         0x01    Address                                  Value     

    Emergency Stop       0x02    

    Query Speeds         0x10    

    Query Function       0x11    Address             

    Manage Proxy         0x80    Attach Node         Node ID      
                                                     
                                 0x01                

                                 Attach DCC Address  DCC Address AA.AA    Speed     
                                                                          steps     
                                 0x81                                               
                                                                          (14, 28,  
                                                                          128)      

                                 Detach Node         Node ID      
                                                     
                                 0x02                

                                 Detach DCC Address  DCC Address AA.AA
                                                     
                                 0x82                

   Want to add “Query attached Node IDs” and “Query attached DCC addresses” as instructions.

  2.4.3 Traction Control Reply Message

   MTI: Priority 1, index 15, modifier 0, addressed => MTI 0x05E8, CAN frame [195E8sss] fd dd

   Higher priority to ensure can be sent immediately over Traction Control Command messages. Coding and
   structure similar.

    Instruction     Byte 0  Byte 1             Byte 2    Byte 3   Byte 4    Byte 5  Byte 6  Byte 7  Byte 8  

    Query Speeds    0x10    Set Speed                    Status   Commanded Speed   Actual Speed
    Reply           

    Query Function  0x11    Address                               Value     
    Reply           

    Manage Proxy    0x80    Attach Node Reply  Node ID                                              Reply   
    Reply                                                                                           Code    
                            0x01               

                            Attach DCC         DCC Address AA.AA  Speed     Reply   
                            Address Reply                         steps     Code    
                                                                            
                            0x81                                  (14, 28,  
                                                                  128)      

                            Detach Node Reply  Node ID                                              Reply   
                                                                                                    Code    
                            0x02               

                            Detach DCC         DCC Address AA.AA  Reply     
                            Address Reply                         Code      
                                               
                            0x82               

   The Query Function Reply is in the format of the Set Function message, with a different MTI and the
   query bit set.

   Attach reply code: Zero or not present, OK

   Detach reply code: Zero or not present, OK

   Do we want to return the number of attached nodes/DCC addresses?

   Error codes need to be defined.

     * Allocation Failed, temporary (try again) handles race conditions (but we need to look carefully at
       that race condition in practice: With the current structure, does it end up adding two DCC addresses
       to the single proxy, instead of reserving it? Probably need to separate out
       reservation-for-configuration. In general, two different things like “assign” and “reserve” should
       be handled by two separate things)

     * Allocation Failed, permanent (out of proxies, etc)

   Want to add responses to “Query attached Node IDs” and “Query attached DCC addresses”. These have
   unbounded length if the number of members in a consist is not bounded by the protocol. Could be a single
   large message, but everybody in the communication path still needs a maximum message size to ensure
   buffering. So a multiple message (or multiple datagram) response with an “last one” bit is the way to
   go. Using datagrams is more protocol work, but leverages existing protocol support and moves the
   response to a lower priority.

   The Query Speed/Direction reply is almost in the Set Speed/Direction format, with the addition of the
   two additional speeds. If a node cannot provide any of those three speeds, it should use float16 NaN
   (not a number) 0xFFFF. “Set Speed” is the most recent speed received in a Set Speed/Direction
   instruction. “Commanded Speed” is the speed that the traction control is currently attempting to move,
   taking into account momentum and any other control modifiers. “Actual Speed” is the current measured
   speed of the locomotive. There is no accuracy guarantee for Actual Speed.

   On CAN, the Query Speed/Direction reply does not fit in a single frame, so it's sent as two frames with
   start and end marked in the 1^st data nibble (high part of destination address). The status byte was
   included so that the actual speed value would not be split across boundaries (though that's not
   necessarily guaranteed for other wire protocols that come along later) The status byte is reserved. Send
   0x00, don't check on receipt. For example, from node with alias 123 to node with alias 456, all speeds
   equal to 0x4420 would be sent as the two frames:

   195E8123 14 56 10 44 20 00 44 20

   195E8123 24 56 44 20

2.5 States

   Full OpenLCB nodes do not have any identified states for this protocol. (They do remember their speed,
   direction and functions) Emergency stop is not a state.

   Proxy Node States:

     * Idle – not allocated to a specific legacy address

     * InUse – allocated to a specific legacy address and controlling the equipment (if any) at that
       address.

   The IsInUseProxy and IsIdleProxy Event IDs are used to indicate transitions in the state of a proxy
   node. Proxy nodes are created in Idle state.

2.6 Interactions

   Emergency Stop

   Receipt of the Emergency Stop instruction stops the locomotive as fast as possible. This sets the set
   speed to zero (preserving existing direction) and the commanded speed to zero (preserving existing
   direction) regardless of any momentum, BEMF or other operations with the train node.

   Emergency stop is not specific state. The next Set Speed/Direction instruction will act immediately to
   change the set speed, and start the commanded speed and actual speed moving toward that set speed.

  2.6.1 Function Operation

   Function values are stored in the 0xF9 memory space. They are written using the memory configuration
   protocol.

    2.6.1.1 Function Definition

   “Function Definition Information”, similar in intent to Configuration Definition Information (CDI) is
   stored in XML format in address space 0xFA to provide user-oriented context. That includes:

     * Memory layout of the function values, allowing for multiple data types from binary (one and off for
       lights) through integer values (for e.g. sound intensities) and strings (sign displays?).

     * Function naming, so that a throttle can display useful names to the user such as "Bell", "Coupler
       Clank" and "Master Volume". This includes internationalization of those labels.

   What else needs to be conveyed? "Make this prominent on the throttle"? "Have this there, just a little
   less prominent"? "Seriously, nobody cares about this option, bury it"?

   At present, there are no default values that e.g. associate "Bell" with a particular location or
   function. These are thought to be too brittle, and there are just too many possibilities to be useful
   (see the unscientific and incomplete Survey of existing function names).

  2.6.2 Train Configuration

   Trains are OpenLCB nodes just like any other. As such, the Memory Configuration protocol can be used to
   configure them, the Configuration Description Information system can be used to make that process user
   friendly, etc. There's nothing traction-specific in these techniques, which are available any time that
   the train node is connected to the OpenLCB.

   The configuration information in a train can include the user documentation that's sometimes referred to
   as "roster information". This might include owner name, prototype railroad and road number, information
   about the particular model's construction, etc. As yet, OpenLCB has no standards nor conventions on this
   information.

   One approach to standards in this area would be extend ACDI/SNIP. Those currently have a block for
   manufacturer identification, and a block for user identification. Those are both versioned. We could
   take (one of) several approaches:

     * Extend them with a third block, only present when the node implements the train protocol (as seen in
       PIP). To allow later introduction of more types, this block would have some versioning/type
       information, but that's straightforward.

     * Create a version 2 of the user block, which holds additional data. (This would be using 2 as a
       format identifier, rather than a version number; that might make versioning complicated)

   Suitable content for a (first version of) this might be (from [
   http://jmri.org/JavaDoc/doc/jmri/jmrit/roster/RosterEntry.html JMRI roster], see also similar concepts
   in [rocrail.net RocRail]):

     * Road Name

     * Road Number

   (Manufacturer, model, owner description, comments, etc are already present in ACDI/SNI)

   For DCC locomotives, more terms might be desired:

     * DCC Address

     * Decoder Type (Manufacturer, model)

  2.6.3 Train Identification

   OpenLCB Train nodes use:

     * The Event Transport protocol to locate Train nodes

     * PIP for enquiry about the support

     * SNII and/or Memory configuration, CDI & ACDI for identification of a specific train node.

   Trains are OpenLCB nodes just like any other. As such, they can take part in protocols such as Node
   Verification and Simple Node Information which allows other nodes to learn about them.

   Train Acquisition Protocol is necessary because the train operator doesn't want to pick up a throttle
   and enter "06.011.00.02.1F.2D" (a node ID), or even "110 Long" (a DCC address), but rather just pick the
   desired locomotive from a list of those available. (A throttle should still allow the operator to
   directly enter the address, when that's what the operator wants to do.)

   The train acquisition process simplifies locating desired train nodes so that small hand-held throttle
   nodes can efficiently take part. It does this using several approaches, which can be used as needed by
   throttles:

     * Events are used to announce the existence and status of Train nodes

     * Train nodes will generally implement the Simple Node Information protocol so that throttles can get
       basic, user-readable identification from them

     * A search protocol is (being) defined to make it possible to locate individual Train nodes without
       having to read information from all of them

   So that other nodes can find them, Train nodes must produce the well-known reserved event
   01.01.00.00.00.00.03.03. This means they must sent that event in a Producer/Consumer Event Report
   message when they power up, and reply to requests for producers of that event. They must also produce
   the reserved event 01.01.00.00.00.00.03.04 if they are not allocated to a physical train (e.g. an unused
   proxy Train node), or 01.01.00.00.00.00.03.05 if they are allocated to a train (e.g. a real Train node
   or proxy Train node that is in use). (Both show up; only one is valid at a time)

   For the special case of nodes that implement connections to legacy equipment (proxies), specific
   addresses have been assigned. For example, nodes that implement communications to DCC decoders must be
   available at the well-known node ID 6.1.0.(CS number).(address), where address is the long or short NMRA
   DCC address for a decoder. (Nodes that communicate with a particular decoder may also appear at other
   node addresses, if desired)

   SNIP will be used to carry both manufacturer-provided and user-provided information about the particular
   train node. In particular, the user (Node) Name and (Node) Description fields are to be used to hold
   train identification information that can be retrieved and presented by throttles for selection.

   A search protocol needs to be defined to allow efficient location of specific train nodes on large
   OpenLCB installations. It provides a general or field-specific search over the SNIP information,
   returning the Node IDs of matching Train Nodes. One proposal, which is not based on memory configuration
   & SNIP, is available here in pdf format and here in OpenOffice Writer.

   Trains are OpenLCB nodes just like any other. As such, they can take part in protocols such as Node
   Verification and Simple Node Information which allows other nodes to learn about them.

   This is necessary because the train operator doesn't want to pick up a throttle and enter
   "06.011.00.02.1F.2D" (a node ID), or even "110 Long" (a DCC address), but rather just pick the desired
   locomotive from a list of those available. (Throttle should still allow the operator to directly enter
   the address, when that's what the operator wants to do.)

   The Train Acquisition Protocol simplifies this process so that small hand-held throttle nodes can
   efficiently take part.

   The protocol uses three well-known event IDs:

   01.01.00.00.00.00.03.03 (isTrain) This node is a Train (or Train Proxy)

   01.01.00.00.00.00.03.04 (isIdleProxy) This node is an idle Train Proxy, not associated with a Train

   01.01.00.00.00.00.03.05 (isInUseProxy) This node is an in-use Train or Train Proxy

   (The last two are specific to proxy-based implementations, here for completeness; see e.g. the DCC page
   for more info)

   All Train nodes produce the isTrain event. That means they announce it when they first come up, respond
   to EventProduced requests for it, and list it when replying to IdentifyEvent messages.

   An EventProduced request will therefore find all the train nodes on the OpenLCB, and further protocols
   can be used to get additional information on the individual Train nodes it locates.

                                    3 Section TitleBackground Information

3.1

                                               4 Section Title

4.1 Subsection Title

  4.1.1 Sub-subsection Title

   Praesent gravida pulvinar vehicula. Vivamus eu nisl eget sem rutrum suscipit id a magna. Integer id ante
   odio.

     * Lorem ipsum dolor sit amet, consectetur adipiscing elit.

     * Sed consectetur, ipsum et egestas accumsan, felis erat ornare mauris, sit amet suscipit ante orci
       sed massa.

                                               5 Section Title

   Quisque sollicitudin tempor bibendum. Donec consectetur condimentum sollicitudin. Sed dignissim velit id
   felis lacinia at eleifend nisi laoreet. Vivamus tristique porta ornare. Vivamus feugiat dolor id lectus
   aliquet luctus.

   Quisque sollicitudin tempor bibendum. Donec consectetur condimentum sollicitudin. Sed dignissim velit id
   felis lacinia at eleifend nisi laoreet. Vivamus tristique porta ornare. Vivamus feugiat dolor id lectus
   aliquet luctus.

   Quisque sollicitudin tempor bibendum. Donec consectetur condimentum sollicitudin. Sed dignissim velit id
   felis lacinia at eleifend nisi laoreet. Vivamus tristique porta ornare. Vivamus feugiat dolor id lectus
   aliquet luctus.

   Quisque sollicitudin tempor bibendum. Donec consectetur condimentum sollicitudin. Sed dignissim velit id
   felis lacinia at eleifend nisi laoreet. Vivamus tristique porta ornare. Vivamus feugiat dolor id lectus
   aliquet luctus.

   Quisque sollicitudin tempor bibendum. Donec consectetur condimentum sollicitudin. Sed dignissim velit id
   felis lacinia at eleifend nisi laoreet. Vivamus tristique porta ornare. Vivamus feugiat dolor id lectus
   aliquet luctus. Proxies

  5.1.1 Lifecycle & Location

   Proxies have a lifecycle:

    1. They are created. This might be when a physical node (the proxy or a physical node hosting a number
       of proxies within it) comes up, or they might be produced as needed.

    2. They get allocated to a particular legacy address

    3. They are used to operate the equipment at that legacy address. (Although this is optional, it's the
       whole point of having the proxy)

    4. They are deallocated. (Items 2 through 4 are a loop, and can happen multiple times)

    5. Finally, they are destroyed. (This is optional; a proxy may stay around until the layout is powered
       off)

   So long as the proxy can do it's job, there's nothing that requires the proxy to be resident in the
   command station hardware. It can be a separate board, in a computer somewhere that talks to pre-existing
   legacy equipment, or something else. One way for OpenLCB vendors to support DCC is to put the proxies
   and a command station in a single unit, but that's not required. Another approach would be an
   OpenLCB-compatible board that provides proxies, which then talk out through a LocoNet, XpressNet, TMCC
   or other connection to a legacy command station of a particular type.

   The simplest way to provide N proxies is to have N nodes appear when the layout turns on. At any given
   instant, only one idle proxy is needed, so another approach would be to create them as needed. In this
   case, the newly created ones will get link access (e.g. go through the process of getting an alias on
   CAN), then announce their existence with an InitializationComplete message followed by
   ProducerIdentified and ConsumerIdentified messages as needed. Those can be used by Throttle nodes to
   track the NodeID of available proxies without having to query for one. Note that this process needs to
   be very fast, so that multiple throttles needing to allocate proxies at the same time can reliably do
   it.

  5.1.2 Proxy Allocation

   Mostly about location of an Idle proxy.

    5.1.2.1 Collisions During Allocation

  5.1.3 Consisting

   Proxy can handle multiple node IDs (and/or DCC addresses), which allows implementation of consisting.
   Speed/direction just passes through; speed matching is automatic due to the use of scale meters/second
   for units.

   It's up to the proxy how to handle pass-through of functions. (Do we need to have a way to specify which
   of the included nodes IDs (and/or DCC addresses) are special, e.g. front or rear locomotive, in the
   setup?)

   It's up to the proxy how to handle pass-through of configuration read and/or writes. Probably just don't
   allow them, or allow them only for configuration of the consist itself (e.g. how to do certain pass
   throughs)

5.2 Speed Control

   Rationale: The use of a 16-bit floating point permits relatively precise speed commands, especially at
   lower speeds; such fine granularity ensures not just fine-grained control over the locomotive, but helps
   avoid aliasing issue that arise during the conversion to lower resolution system-specific speed commands
   (i.e. DCC's 14 or 28-step commands).

   The use of meters per second is somewhat arbitrary, and reflects standard velocity units used throughout
   the metric-speaking world. By standardizing on m/s, we avoid any future unit conversion issues.

   The use of scale meters per second has two distinct advantages. First, it permits us to transmit speed
   commands in a scale-independent way. Second, and because of this, it reduces the number of parameters
   that must be estimated when controlling a locomotive that has not yet been speed-calibrated (which, for
   new users using existing digital control systems, will be all of their models). For example, on a DCC
   system, if I issue a command to proceed at 30mph, the command station must convert the value in the
   speed command from 30mph to an integer in the range [0-26] (for 28-speed-step control). The command
   station need only estimate what a reasonable top speed for a locomotive might be: Let us say, 100mph.
   Thus, the command station could reasonably estimate that 30mph translates to speed step 8.

   The alternative possibilities considered to date are absolute speed using real units (as opposed to
   scale units), and relative speed units. The difficulty with relative speed units (i.e., percentage of
   full throttle), is that they are ambiguous, and preclude the possibility of performing physical
   simulations in the cab controller, at least without completely abandoning the particular interpretations
   assigned to sped values. The difficulty with using real (as opposed to scale) units is that it requires
   the estimation of an additional parameter for uncalibrated locomotives, specifically the train's scale.
   If I issue a command to a DCC locomotive to proceed at 0.1 (real)m/s, the command station must not only
   understand what a reasonable top speed for a train is, but how to scale the speed appropriately, as 0.1
   m/s might be quite fast for Z scale, but quite slow for G. As there is really no reasonable scale to use
   as a default, users must configure their digital command station to set the scale for either the entire
   layout, or on a per-model basis—an additional configuration step that is easily avoided by the mechanism
   for scale units described above.

5.3 Function Control

   "Functions" like "horn", "headlight", etc are key user features when operating modern decoders. But
   they're also configuration-like, in that they effect the operation of the device.

   How to handle them for a native OpenLCB piece of rolling stock, and for legacy ones via e.g. DCC?

   We could take the purist approach and say "configuration is configuration, it's all the same". But that
   ignores that many people are going to want "Bell" to appear (automatically) on their throttle, but not
   so many are going to want "Kp back-emf correction factor" to appear there.

   People just think about operating and configuring their locomotives as separate things. (Though e.g.
   "Master Volume" can cross the line)

   This doesn't mean that we can't use the same protocol for all other of them. A mixture of memory
   configuration and CDI should do just fine. It just means that we need to find a way to include clueing
   information for the throttles on e.g. what to present.

   Outputs vs Functions

   Tools like DecoderPro and its decoder-definition files make a distinction between "functions", which are
   the control commands sent via e.g. DCC, and "outputs", which are the things that a decoder can do:
   Control an electrical output, make a sound, etc. This distinction is useful because one of the
   configuration options in (some) DCC decoders is a mapping between the functions and the outputs, useful
   in a world where throttles generally have only about a dozen buttons, but decoders have many output
   options.

   OpenLCB makes a clean separation between functions, which are the control operations, and all
   configuration & physical information, which lives in the memory configuration and CDI. If there's to be
   a mapping, it's defined through the CDI.

5.4 Legacy Train Operations

  5.4.1 Configuration

   For DCC trains, there are two parts:

     * CV access (with the added complexity of indexed and double-indexed Cvs)

     * Programmer (main, programming track) control.

   Table of Contents

   1 Introduction 1

   1.1 Terminology 1

   1.2 Served Use Cases 2

   1.2.1 Train Operation 2

   1.2.2 Large Modular Layout 2

   1.2.3 Train on New Layout 2

   1.2.4 Legacy Train on New Layout 2

   1.3 Unserved Use Cases 2

   1.3.1 Multiple Independent Command Stations 2

   1.3.2 Improved Legacy Addressing 3

   1.3.3 Third-Party Communications 3

   2 Specified Sections 3

   2.1 Introduction 3

   2.2 Intended Use 3

   2.3 Reference and Context 3

   2.4 Message Formats 3

   2.4.1 Defined Event IDs 3

   2.4.2 Traction Control Command Message 3

   2.4.3 Traction Control Reply Message 4

   2.5 States 6

   2.6 Interactions 6

   3 Background Information 7

   3.1 Proxies 7

   3.1.1 Lifecycle & Location 7

   3.1.2 Proxy Allocation 7

   3.1.2.1 Collisions During Allocation 7

   3.1.3 Consisting 7

   Copyright 20113. All rights reserved. See http://openlcb.org/Licensing.html for license terms.  Page 1
   of 11 - 4/29/2013Apr 29, 2013
