   PowerPlusWaterMarkObject1

                                                                OpenLCB Standard

                                                         Simple Time Broadcast Protocol

                                                    Sep 1, 2018                        Preliminary          

                                         1 Introduction (Informative)

   A layout control bus can do a number of useful things with fast-time information:

     * Connect a number of clock displays to keep them synchronized.

     * Provide time displays on plug-in devices, e.g. throttles.

     * Provide cueing for time-based occurrences, such as lights turning on and off at specific modeled
       times.

   Generally, existing fast clock systems have one unit that produces time information, here called a clock
   generator, and one or more units that consume it. Existing fast clock systems typically only report
   minutes, not seconds or finer time divisions. Some existing fast clock systems track a day/date, in
   addition to time.

   Fast clocks run at various rates, and can be controlled by the user either at the producer nodeclock
   generator or from other locations. Some fast clock systems broadcast run/stop and rate information,
   which can also be useful when interpolating within a fast-minute or between time sync Events.

   OpenLCB broadcasts time information by producing Event IDs. Specific Event IDs correspond to specific
   times with the day, for example “08:10:00”, so that consumers can be taught to react to time-of-day. The
   year and date are handled separately, for those installations that choose to use it.

                                         2 Intended Use (Informative)

   The primary use of this information is to display timeit on clock faces around the layout.

   Since remote control of the fast clock is desired, a set-protocolprotocol for setting up the time
   producer using produced and consumed events is defined. This makes it possible for throttles and other
   user-interface nodes to have a general fast-clock-control capability built in.

   In addition, simple nodes can use specific EventIDs to trigger their actions at specific times. For
   example, lights in buildings in a model town can be sequenced to come on at various times by configuring
   consumers in a node to react to time events by changing output lines. Most importantly, in this use
   case, the consuming node does not need to be aware that the event is related to time.

                                     3 References and Context (Normative)

   This specification is in the context of the following OpenLCB-CAN Standards:

     * OpenLCB Event Transport Standard, which defines messages for transporting Event IDs and identifying
       producers and consumers.

     * The OpenLCB Event Identifiers Standard, which defines the format and content of Event IDs including
       the class of Well-Known Event IDs and Automatically-Routed Event IDs.

     * OpenLCB Unique Identifiers Standard, which defines the allocation of OpenLCB 48-bit unique
       identifiers

   For more information on format and presentation, see:

     * OpenLCB Common Information Technical Note

                                        4 Message Formats (Normative)

   This Standard defines a number of Event IDs.

   as 0x01.01.00.00.00.00.05.01..he well-known event ID “Delivers Clock Protocol” is definedTIn addition to
   the following Event IDs, t

   The upper six bytes of the event IDs defined in the following subsections shall be one of the following:

     * 01.01.00.00.01.00 – referred to as “Default Fast Clock”

     * 01.01.00.00.01.01 – referred to as “Default Real-time Clock”

     * 01.01.00.00.01.02 – referred to as “Alternate Clock 1”

     * 01.01.00.00.01.

     * The upper six bytes of the following messages must be the valid Node ID of the clock producing node.

   Note that there are no well-defined values of the clock event IDs. You locate the clock generators and
   their event spaces via the usual IdentifyEvent/IdentifyProducer mechanisms starting with the “Delivers
   Clock Protocol” event ID.

     * The details of the following formats are still being worked out. 03 – referred to as “Alternate
       Clock 2”

     * a valid unique ID under the control of the manufacturer of the clock generator node

     * a valid Unique ID under the control of the person or organization configuring the clock generator
       node

   The values are packed into two bytes to make it easier to allocate the unique “Specific Upper Part”; it
   is required to be the Node ID of the clock generator.The upper six bytes are referred to as the
   “Specific Upper Part” in the subsections below. In portions of this document, the “Specific Upper Part
   is also represented by the notation XX.XX.XX.XX.XX.XX.

4.1 Set/Report Time Event ID

    Byte 0       Byte 1       Byte 2      Byte 3      Byte 4      Byte 5      Byte 6           Byte 7       

    Specific Upper Part                                                       Hours            Minutes      
                                                                              0x00-0x1723      0-59         

   The upper nibble of byte 6 is only 0 or 1, which can be used to distinguish this format.

4.2 Set/Report Date Event ID

    Byte 0       Byte 1      Byte 2      Byte 3      Byte 4      Byte 5      Byte 6             Byte 7      

    Specific Upper Part                                                      0x240+Month        Day         
                                                                             0x241-0x0x24C      1-31        

   The upper nibble of byte 6 is 24, which can be used to distinguish this format.

4.3 Set/Report Year Event ID

    Byte 0       Byte 1       Byte 2       Byte 3       Byte 4       Byte 5       Byte 6       Byte 7       

    Specific Upper Part                                                           0x3000+Year  
                                                                                               
                                                                                  0x3000-0x3FFF

   The upper nibble of byte 6 is 3, which can be used to distinguish this format.

   The lower twelve bits are the year, 0AD to 4095AD. (It's been proposed that these instead be in some BCD
   format, which represents 999 years around some epoch)

4.4 Set/Report Rate Event ID

    Byte 0       Byte 1       Byte 2       Byte 3       Byte 4       Byte 5       Byte 6       Byte 7       

    Specific Upper Part                                                           0x45000+Rate 

   The upper nibble of byte 6 is 45, which can be used to distinguish this format.

   Rate is a 12 bit signed fixed point rrrrrrrrrr.rr, -511.75, -511.00, …, -1.00, …, -.025, .00, 0.0, 0.25,
   0.50, ..., 511.75 (Is that the right range? Enough granularity? Would something simpler be easier?)

   A rate of zero is valid. The stop/start clock event should be used to stop and start the clock, because
   that doesn't require resetting, or even knowing, the current rate.

   (should one bit be reserved, perhaps in the high nibble, to carry the run/stop state when reporting the
   rate? That was in an earlier proposal, makes it easier to look for the entire state in a single event,
   but it's got messy semantics)

4.5 Report Intermediate Time Event ID

    Byte 0       Byte 1       Byte 2       Byte 3       Byte 4      Byte 5      Byte 6         Byte 7       

    Specific Upper Part                                                             Hours        Minutes    
                                                                                  0x50-0x67       0-59      

   The upper nibble of byte 6 is only 5 or 6, which can be used to distinguish this format.

4.6 Set Time Event ID

    Byte 0       Byte 1       Byte 2       Byte 3       Byte 4       Byte 5       Byte 6       Byte 7       

    Specific Upper Part                                                              Hours       Minutes    
                                                                                    0x80+97       0-59      

   The upper nibble of byte 6 is only 8 or 9, which can be used to distinguish this format.

4.7 Set Date Event ID

    Byte 0       Byte 1       Byte 2       Byte 3       Byte 4      Byte 5      Byte 6          Byte 7      

    Specific Upper Part                                                         0xA0+Month      Day         
                                                                                0xA1-0xAC       1-31        

   The upper nibble of byte 6 is A, which can be used to distinguish this format.

4.8 Set Year Event ID

    Byte 0       Byte 1       Byte 2       Byte 3       Byte 4       Byte 5       Byte 6       Byte 7       

    Specific Upper Part                                                           0xB000+Year  
                                                                                               
                                                                                  0xB000-0xBFFF

   The upper nibble of byte 6 is B, which can be used to distinguish this format.

   The lower twelve bits are the year, 0AD to 4095AD.

4.9 Set Rate Event ID

    Byte 0       Byte 1       Byte 2       Byte 3       Byte 4       Byte 5       Byte 6       Byte 7       

    Specific Upper Part                                                           0xC000+Rate  

   The upper nibble of byte 6 is C, which can be used to distinguish this format.

4.10 Latch Settings Event ID

    Byte 0       Byte 1       Byte 2       Byte 3       Byte 4       Byte 5       Byte 6       Byte 7       

    Specific Upper Part                                                           0xF000       

   The upper nibble of byte 6 is F, which can be used to distinguish this format.

4.11 Stop/Start Event ID

4.12 Clock

    Byte 0       Byte 1       Byte 2       Byte 3       Byte 4       Byte 5       Byte 6       Byte 7       

    Specific Upper Part                                                           Stop 0x6001  
                                                                                               
                                                                                  Start 0x6002 

   The upper nibble of byte 6 is 56, which can be used to distinguish this format.

4.13 Undefined/Reserved Event ID’s

    Byte 0   Byte 1   Byte 2   Byte 3   Byte 4   Byte 5   Byte 6                   Byte 7                   

    Specific Upper Part                                   All byte 6 and byte 7 values not defined above

   (Could have also put into higher part of e.g. month message, to save this code space)

   Having a separate start/stop mechanism, instead of just setting rate to zero, makes distributed
   start/stop control easier. There's no need for everybody to remember the current rate while the clock is
   stopped.All undefined byte 6 and byte 7 values are reserved for future use. They shall not be sent. If
   received, they shall be ignored.

                                             5 States (Normative)

   Each clock has an independent current time, independent running/stopped state and an independent rate.

   When the clock is in stopped state, its internal time is not changing.

   When the clock is in running state, its internal time is advancing (rate X) as fast as normal time.

                                          6 Interactions (Normative)

   In order to ensure that time is only ever represented as an atomic operation, changes in Rate, Year,
   and/or Date may optionally become valid upon reception of the next Report Time Event or Report
   Intermediate Time Event.

6.1 Startup

   When a clock generator starts to operate, it shall send a Producer Range Identified message covering the
   whole 16-bit range of the clock’s 6-byte “Specific Upper Part”. Additionally, the clock generator shall
   send a Producer Identified as Currently Valid message for either the Stop Event ID or the Start Event ID
   corresponding with its current start/stop state. Cock consumers shall send either a Consumer Range
   Identified message covering the whole 16-bit range of the clock’s 6-byte “Specific Upper Part” or
   individual Consumer Identified messages for each individual time event consumed.

  6.1.1 Clock Generator

   When a clock on a clock generator is started (from a previously stopped or power up state), upon
   reception of a Latch Settings Event, or upon reception of a Identify producer message for the Event ID
   XX.XX.XX.XX.XX.XX.00.00, it shall produce the following events in the following specific order
   representing a single atomic time:

    1. Report Rate

    2. Report Year

    3. Report Date

    4. One of the following events

         1. Report Intermediate Time, if the seconds count is not equal to zero

         2. Report Time, if the seconds count is equal to zero

    5. Report Time (continuously as described in section 6.2 below, only if clock is running)

  6.1.2 Clock Consumer

   A clock consumer can request the current running state of a clock by sending an Identify Producer
   message for either of the Start or Stop Clock Events. If a clock generator for the given clock exists,
   it shall respond with the corresponding Producer Identified as currently Valid or Invalid as
   appropriate.

6.2 Clock Report

   If no consumer of a given clock event has been identified, the clock generator is not required to
   produce it.

   While running, a clock generator shall send a Report Time Event no more frequently than  once per real
   world minute with the following exceptions:

    1. When the time rolls over to hour 0 and minute 0, the entire in order sequence described in section
       6.1.1 above. This ensures that the year and date are correctly reflected as a result of the
       rollover.

    2. The clock generator has previously received a Consumer Identified message for a specific Report
       Year, Date, or Time Event, in which case it will always generate this event when appropriate.

   It is the responsibility of clock consumers to keep track of intermediate time between Report Time
   Events. The standard purposely does not define how a clock consumer internally implements time. If a
   clock consumer wants to get the current time in minute resolution, it shall do so by sending an Identify
   Producer message using the Event ID XX.XX.XX.XX.XX.XX.50.00.

6.3 Cock Set

   Any node may configure a clock generator. It is not a requirement that a clock generator support the
   capability to change its configuration using events. If Set Rate, Set Year, Set Date, and/or Set Time
   Event(s) are received, the clock generator does not make the change effective until a Latch Settings
   Event is received. Upon receiving a Latch Settings Event, the entire in order sequence described in
   section 6.1.1 above shall be sent by the clock generator.

   If a Set Rate Event is received by the clock generator, the clock generator's rate may be, but is not
   required to be, set to the rate embedded in the event. If the clock producer does not support the
   requested rate, it shall move to the closest non-zero supported rate. The clock-generator shall
   subsequently, send the entire in order sequence described in section 6.1.1 above. The rate may be set
   while the clock is running or stopped.

   When a clock producer node receives an IdentifyProducers message that covers any of the events it
   handles (Set/Report Time, Set/Report Date, Set/Report Year, Set/Report Rate, Stop/Start Clock) it will
   reply with a ProducerIdentified message showing valid. If the queried event is the current state (same
   time, same date, same year, same rate & start/stop status, or same start/stop status respectively), the
   reply will be marked active. Otherwise, it will be marked inactive.

   When a clock producer node receives an IdentifyConsumers message that covers any of the events it
   handles (Set/Report Time, Set/Report Date, Set/Report Year, Set/Report Rate, Stop/Start Clock) it will
   reply with a ConsumerIdentified message showing valid. If the queried event is the current state (same
   time, same date, same year, same rate & start/stop status, or same start/stop status respectively), the
   reply will be marked active. Otherwise, it will be marked inactive.

     * An IdentifyProducedEvent message for the well-known event ID “Delivers Clock Protocol”

     * All of the preceding may be in any order, but the given order is recommended.

   (There's actually an standards issue here – with the current coding, the Date events don't occupy more
   than half of the reported range)

     * An IdentifyProducedEvent message for the current year showing valid & active

     * An IdentifyProducedEvent message for the current date, showing valid & active

   An IdentifyProducedEvent message for the current time, showing valid & active (if start/stop not in the
   event, also a stop/start event for the valid case), showing valid & active (and start/stop state?)An
   IdentifyProducedEvent message for the current rateAn IdentifyProducedEvent message for the current start
   or stop state, showing valid & active

     * An IdentifyProducedEvent message for the well-known event ID “Delivers Clock Protocol”

     * A ProducerRangeIdentified that covers the entire set of time event IDs

     * A ConsumedRangeIdentified that covers the entire set of time event IDs

   :

   , in order reply withshallwillthe node When a clock producer node receives an Identify Events message,
   When a clock producer node receives an Identify Events message, it replies with an IdentifyProducedRange
   and an IdentifyConsumedRange that covers the entire set of time event IDs.

   In addition,

6.4 Event Identification and Reporting

   The use of the same event to broadcast the rate and to set the rate should perhaps be revisited. Is that
   consistent with event semantics? Or should a “rate set event” do the set and cause the clock source to
   emit a “current rate” event? There's no security issue here, because we receive the Node ID of the
   set-sending node either way. And a clock receiving a set command, no matter what the format, can still
   decide not to do it (if the protocol allows rejecting that, see above) The clock producer node may, but
   is not required to, produce a Set/Report Time immediately after the rate event is produced to ensure
   that all agree on the exact time. be set while the clock is running or stopped. The rate mayRate can to
   the closest non-zero supported rate, and produces a Set/Report Rate event containing the current rate.
   ll moveshamovesdoes not support the requested rate, it producer f the clock IThe run/stop bits are
   ignored. I set to the rate embedded in the event. may be, but is not required to be,is produced
   immediately after.

   If a Set/Report Rate event is received, the clock-producer's rate shall beisa Set/Report Time event is
   received at a clock-producer node, it may, but is not required to, set the time in the clock producer
   node. If the time is not set, the current time event

   When (Should it be periodically produced, e.g. every real minute, when the clock is stopped? That
   updates recent joiners, but it's nice to be able to stop all network traffic). produced every time the
   current time changes, e.g. every fast minute. shall beis

   A Set/Report Time event When clock producer nodes receive a Set/Report Year event they may, but are not
   required to, update their internal state to the year in the event. If they do not update their internal
   year to the received one, they shall produce a Set/Report Year event with their current year. Clock
   producer nodes shall produce a Set/Report Year event if they receive one but do not update their
   internal date.

   to the received one, they shall produce a Set/Report Date event with their current date..do not update
   their internal dateIf they f they receive one but they may, but are not required to, update their
   internal state to the date in the event. a Set/Report Date event receiveshall producelock producer nodes
   When cC

   (Should these also be produced periodically? How often?) produced when the year changes.shall beisevent
   Year Date produced when the date changes. The Set/Report shall beis Set/Report Date event AThe

   . to update the layout. (Should the current one also be produced when the clock is not running?
   Sometimes nice to be able to stop all traffic on the network, which you can do if it doesn't send while
   the clock is stopped) seconds while the clock is running(?) produced every real 60shall be are

   A Set/Report Rate event for which there are one or more consumers (Note that this is operating, not
   running; if it's serving as a clock generator and will produce and consume the appropriate event IDs)
   “valid” if the clock is operating, and “invalid” if it is not. a ProducerIdentified message with
   returnshallhas to, the node receivedenquired aboutenquiry about “Delivers Clock Protocol” is a
   IdentifyProducers The well-known event ID “Delivers Clock Protocol” shall be produced by every node when
   it first starts to operate as a clock generator. When

   Table of Contents

   1 Introduction (Informative) 1

   2 Intended Use (Informative) 1

   3 References and Context (Normative) 1

   4 Message Formats (Normative) 2

   4.1 Report Time Event ID 2

   4.2 Report Date Event ID 2

   4.3 Report Year Event ID 3

   4.4 Report Rate Event ID 3

   4.5 Report Intermediate Time Event ID 3

   4.6 Set Time Event ID 3

   4.7 Set Date Event ID 4

   4.8 Set Year Event ID 4

   4.9 Set Rate Event ID 4

   4.10 Latch Settings Event ID 4

   4.11 Stop/Start Event ID 4

   4.12 Undefined/Reserved Event ID’s 5

   5 States (Normative) 5

   6 Interactions (Normative) 5

   6.1 Startup 5

   6.1.1 Clock Generator 5

   6.1.2 Clock Consumer 6

   6.2 Clock Report 6

   6.3 Cock Set 6

   Copyright 20133 - 2018. All rights reserved. See http://openlcb.org/Licensing.html for license terms. 
   Page 1 of 8 - Sep 1, 2018
