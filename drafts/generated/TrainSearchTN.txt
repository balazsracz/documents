                                                1 Introduction

   This Technical Note provides background information and commentary to the OpenLCB Train Search Protocol
   Standard. This document is not intended to be read standalone, but in parallel to the matching Standard.

1.1 Background

  1.1.1 Relation to Traction Protocol

   The OpenLCB Network is a peer-to-peer network where Nodes connected to the network can communicate with
   each other using the OpenLCB Network Protocols. These protocols are organized around the different OSI
   layers, and to achieve an end-to-end use-case a multitude of protocols are typically used, from
   different layers1, or in a complementary manner2.

   Some of these protocols are broadcast, meaning that all Nodes receive the messages of the interaction;
   other protocols are addressed, meaning the interaction takes place between two specific Nodes, and other
   Nodes do not receive the messages of the interaction. In order for an addressed interaction to take
   place, the initiating Node needs to know the Node ID of the target Node. This generally requires some
   broadcast protocol using which the initiating Node can discover the possible target Nodes, and present
   these on a user interface to the user to select.

   Considering the interaction of a user using an OpenLCB-connected Throttle to communicate to an
   OpenLCB-connected Train, or an OpenLCB-connected Command Station, we have two protocols that are part of
   this interaction:

     * The Traction Protocol defines the addressed interactions related to driving a train, such as setting
       speed and direction, or operating functions. It takes place between one Throttle and one or more
       Train Node(s) that are controlled.

     * The Train Search Protocol is a broadcast protocol that specifies interactions needed for the
       Throttle to identify the Node ID of the Train Node that the user intends to drive.

  1.1.2 Relation to Legacy Track Protocols

   Trains may or may not be equipped with the necessary technology to directly participate in the OpenLCB
   Network. For now and the foreseeable future, an overwhelming majority of digitally controlled trains
   will be using a mobile decoder that operates using an existing standard or proprietary method of
   transmitting commands to the mobile decoder through the track, such as the NMRA® DCC® protocol suite.

   In such a setting, there is a centralized component called Command Station which is responsible for
   generating the track protocol signal. This device has to receive commands from the Throttles, and
   translate them to remote control the mobile decoders built into the trains rolling on the track. The
   Command Station is then responsible for participating on the OpenLCB Network and representing the remote
   trains. The Traction Protocol requires each train to be a separate OpenLCB Node with its own Node ID,
   therefore the one Command Station device will be operating a number of Virtual Nodes, one per actively
   controlled train. All of these Virtual Train Nodes participate in the Train Search Protocol so that
   Throttles can discover, find and operate the trains connected to the track.

   An important question then becomes: how does the Command Station know when the user intends to address a
   new train on the track that does not yet have a matching Virtual Train Node. The Train Search Protocol
   addresses this use-case as well.

  1.1.3 Relation to other Search and Discovery Protocols

   Note that the existence of Train Search Protocol does not exclude other methods and standards, including
   some not yet developed, for the same or similar purposes. There are also possibilities of using less
   capable existing Standards to achieve similar results (covering some but not all use-cases), albeit at a
   higher cost for the Throttle Node in terms of the necessary resources (above all RAM) and higher number
   of network messages to send and keep track of.

   Some of these options are described in the Alternatives Considered section below (TODO: replace with
   reference).

1.2 Served Use Cases

     * The User is holding a Throttle connected to the OpenLCB Network. The Throttle has a numeric keypad
       and no screen. The user types in the four digit cab number they see on the locomotive and presses
       the Enter key. The Throttle uses the Train Search Protocol to find the matching OpenLCB Node. Then
       the throttle uses the Traction Protocol to connect to that Train Node, and the user is able to drive
       the train.
       Note that this use-case presents the same way if the train itself has a radio-equipped decoder and
       is directly participating on the OpenLCB network; and also if the train has a DCC decoder and
       represented by a Command Station on the OpenLCB Network.

     * The user owns a locomotive with road number 474 014 with a legacy track protocol decoder. The user
       does not remember what address is assigned to the decoder, but there is a Roster (locomotive
       database) in the Command Station, which has a record of the track address, and the name “Re 474 014”
       is assigned to this record. The user has a Throttle with a numeric keypad and a screen, and types in
       474 on the keypad. The Throttle uses the Train Search Protocol to look for matching entries on the
       network. The Command Station searches through the Roster, instantiates the matching Virtual Nodes,
       provides the list of matching Node IDs to the Throttle. The Throttle queries the user-visible names
       of those Nodes using the Simple Node Information Protocol and presents a list to the user to select
       from. The user selects “Re 474 014”, and starts driving the train.

     * The user purchased a new locomotive which came with a Marklin-Motorola format mobile decoder with
       address 72. The user puts it onto the track, types in 72 on the throttle, selects the
       Marklin-Motorola track protocol using option keys, and presses Enter. The user is in control of the
       locomotive.

     * A friend comes over and brings a DCC-equipped locomotive with them. They warn that the locomotive
       has a very old decoder. The user enters the address on the Throttle, selects the DCC-14-speed-step
       protocol using option keys, and presses Enter. The user is in control of the locomotive.

1.3 Unserved Use Cases

     * The Train Search protocol is not a generic search protocol. It is not possible to search for any
       other entity than a Node3. While the concept could be used for searching for other types of nodes,
       the specific allocation shall only be used for searching for Train Nodes. This is necessary in order
       to ensure that Throttles that use this allocation properly function on the network.

     * The search results are only Node IDs. If additional information beyond the Node ID is needed (such
       as user-visible name), the Throttle has to use other protocols (such as the Simple Node
       Identification Protocol) to query that information.

     * Only digits are supported in the search query. The maximum length of the query is 6 digits. Longer
       and alphanumeric search queries are not supported.

     * A Command Station can only receive a signal using the Train Search Protocol when the user wants a
       new Virtual Train Node to be created. The Train Search Protocol does not support giving a signal to
       the Command Station on when to delete a Virtual Train Node.

                                        2 Annotations to the Standard

   The Subsections herein mirror the structure of the Train Search Protocol Standard document.

2.1 Introduction

   Note that this section of the Standard is informative, not normative.

   The Train Search Protocol is built on top of the Event Transport Protocol, which operates using generic
   OpenLCB messages. This means that the Train Search Protocol can operate on any supported OpenLCB
   transport layer, including CAN-bus and TCP. This allows both wired and wireless Throttles to operate
   using the Train Search Protocol.

2.2 Intended Use

   Note that this section of the Standard is informative, not normative.

2.3 References and Context

   There is no reference to the Traction Protocol, which the Throttle would use to drive actual trains.
   This is on purpose, because the scope of the Train Search Protocol ends after the Throttle discovers the
   Node ID.

2.4 Message Formats

   This Standard is built on top of the Event Transport Standard. All of the necessary messages to operate
   this protocol are allocated and defined in that Standard.

2.5 Allocation

  2.5.1 Identifier Range allocation and License terms

   The Train Search Protocol was developed for and proposed as a Standard by Train Control Systems, Inc. It
   is a valid use of the Unique Identifiers allocated to any specific party for that party to develop
   proprietary protocols for operating on the OpenLCB network. It is also valid for this party to offer the
   developed protocol with appropriate documentation as a proposed Standard.

   The licensing terms attached to the Standard allows anyone to create compatible products without any
    concerns related to license fees. It is not permissible however to create an incompatible product.

  2.5.2  Identifier Format

   This section only defines what the individual bits and bytes of the given identifiers are allocated to.
   It is in the Section ‘Interactions’ how the different parties should be using those fields and
   identifiers.

2.6 Interactions

   Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus.

  2.6.1 Search for existing train nodes

  2.6.2 Allocate a new Train Node

  2.6.3 Event Identifier matching algorithm

  2.6.4 Search Result Differentiation

                                          3 Alternatives considered

     * A more generic protocol could be developed for searching for Nodes on the network; this may be
       peer-to-peer or based on a centralized database built and maintained by a single Node that stores
       details about all Nodes available on the network (including all Train Nodes).

       At the time of this writing, no specific proposals exist for this protocol. The requirements space
       and ambiguity in this domain is very large, and initial discussions in the OpenLCB Group have not
       sufficed to identify a straightforward solution to this problem.

     * All Nodes can be enumerated by the unaddressed Verify Node ID Global message. There is no throttling
       mechanism provisioned to maintain the list of replies with a limited amount of memory. The Node list
       can then be further processed using Protocol Support Inquiry (PIP) messages to restrict to Train
       Nodes and Simple Node Information Request (SNIP) messages for querying identifying properties such
       as train name.

       Without a throttling mechanism, using this method to find and identify Train Nodes would require an
       unbounded amount of memory for the Throttle Nodes. This makes it difficult to build simple and cost
       efficient Throttles.

     * All Train Nodes can be identified using the Well-Known Event ID IsTrain. There is no throttling
       mechanism provisioned to maintain the list of replies with a limited amount of memory.

       Without a throttling mechanism, using this method to find and identify Train Nodes would require an
       unbounded amount of memory for the Throttle Nodes. This makes it difficult to build simple and cost
       efficient Throttles.

     * A legacy track protocol Command Station could expose a command interface either via dedicated
       OpenLCB messages or via a Datagram-based protocol to maintain its list of virtual Train Nodes. This
       protocol could also be out-of-band, for example through a user interface (physical or HTTP-based),
       or could be coupled to a persistent database using the Memory Configuration Protocol and the
       Configuration Descriptor (CDI) XML to expose the user interface via a Configuration Tool.

       There was an actual protocol proposal developed for this alternative under the name of Traction
       Proxy Protocol. The difficulty with this approach is that a Throttle can be programmed to operate
       using the Traction Proxy Protocol, which would make the Throttle work well with a Command Station,
       but naturally exclude the ability of this Throttle to connect to native OpenLCB Train Nodes. This
       makes the solution not desirable as a long-term offering, as it does not provide a seamless upgrade
       path to radio-equipped locomotives.

     * Instead of encoding the information to transmit in Event IDs, a protocol could be developed using
       custom OpenLCB messages that are marked as global/broadcast in the MTI. This would allow fewer
       compromises around the encoding.

       Creating a new broadcast protocol would pose difficult questions around buffering and traffic
       routing. The Event Transport Standard has specific preparation about interconnecting different
       network segments with filtering and routing for example. All of these features would need to be
       specifically duplicated to reach a similar performance characteristics as using Events. The
       duplicate features would then have to be specifically implemented by all gateways and routers.

       Even with a protocol defining custom messages, there would be a fairly strict limit on the amount of
       payload bytes that can be transported. This is because there is no generic protocol for transporting
       broadcast messages on CAN-bus with more than 8 bytes of payload.

                                               4 Section Title

4.1 Subsection Title

  4.1.1 Sub-subsection Title

   Praesent gravida pulvinar vehicula. Vivamus eu nisl eget sem rutrum suscipit id a magna. Integer id ante
   odio.

     * Lorem ipsum dolor sit amet, consectetur adipiscing elit.

     * Sed consectetur, ipsum et egestas accumsan, felis erat ornare mauris, sit amet suscipit ante orci
       sed massa.

                                               5 Section Title

   Quisque sollicitudin tempor bibendum. Donec consectetur condimentum sollicitudin. Sed dignissim velit id
   felis lacinia at eleifend nisi laoreet. Vivamus tristique porta ornare. Vivamus feugiat dolor id lectus
   aliquet luctus.

   Quisque sollicitudin tempor bibendum. Donec consectetur condimentum sollicitudin. Sed dignissim velit id
   felis lacinia at eleifend nisi laoreet. Vivamus tristique porta ornare. Vivamus feugiat dolor id lectus
   aliquet luctus.

   Quisque sollicitudin tempor bibendum. Donec consectetur condimentum sollicitudin. Sed dignissim velit id
   felis lacinia at eleifend nisi laoreet. Vivamus tristique porta ornare. Vivamus feugiat dolor id lectus
   aliquet luctus.

   Quisque sollicitudin tempor bibendum. Donec consectetur condimentum sollicitudin. Sed dignissim velit id
   felis lacinia at eleifend nisi laoreet. Vivamus tristique porta ornare. Vivamus feugiat dolor id lectus
   aliquet luctus.

   Quisque sollicitudin tempor bibendum. Donec consectetur condimentum sollicitudin. Sed dignissim velit id
   felis lacinia at eleifend nisi laoreet. Vivamus tristique porta ornare. Vivamus feugiat dolor id lectus
   aliquet luctus.

    

   Table of Contents

   1 Introduction

   1.1 Background

   1.1.1 Relation to Traction Protocol

   1.1.2 Relation to Legacy Track Protocols

   1.1.3 Relation to other Search and Discovery Protocols

   1.2 Served Use Cases

   1.3 Unserved Use Cases

   2 Annotations to the Standard

   2.1 Introduction

   2.2 Intended Use

   2.3 References and Context

   2.4 Message Formats

   2.5 Allocation

   2.5.1 Identifier Range allocation and License terms

   2.5.2  Identifier Format

   2.6 Interactions

   2.6.1 Search for existing train nodes

   2.6.2 Allocate a new Train Node

   2.6.3 Event Identifier matching algorithm

   2.6.4 Search Result Differentiation

   3 Alternatives considered

   4 Section Title

   4.1 Subsection Title

   4.1.1 Sub-subsection Title

   5 Section Title

    

     ----------------------------------------------------------------------------------------------------

   1 Example: The Memory Configuration Protocol is using the Datagram Protocol as a supporting layer.

   2 Example: for end users to configure an OpenLCB Node, the Memory Configuration Protocol is expanded
   with the Configuration Description Information protocol to describe what configuration settings are
   available at which memory offsets.

   3 For example it is not possible to search for an Event.
